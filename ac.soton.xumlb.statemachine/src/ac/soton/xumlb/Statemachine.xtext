// automatically generated by Xtext
grammar ac.soton.xumlb.Statemachine  with org.eclipse.xtext.common.Terminals hidden (WS,ML_COMMENT,SL_COMMENT)
//with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

import "http://soton.ac.uk/models/eventb/statemachines/2014" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://soton.ac.uk/models/eventb/coreextension/2014" as coreextension
//import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore#/" as eventbcore
//import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore" as eventbcore
import "http://emf.eventb.org/models/core/2014" as eventbcore
//import "http://emf.eventb.org/models/core/machine/2014" as emachine
import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore#//machine"as emachine


Statemachine returns Statemachine:
	'statemachine'
	name=ID '(' translation=TranslationKind ')'
//	('annotate' annotations+=[eventbcore::Annotation|EString]+)?
//    ('annotations' annotations+=Annotation+)?
//      annotations+=XAnnotation* 
//    ('elaborates' elaborates=[emachine::Machine|EString])?
    ('annotates' comment = EString)?
	('refines' refines=[Statemachine|QualifiedName])?
	(
	   'instances' instances=[eventbcore::EventBNamedCommentedElement|QualifiedName]
	   'selfName' selfName=EString
	)?
	nodes += AbstractNode*
	transitions += Transition* 
;
//
//Annotation returns eventbcore::Annotation:
//	{eventbcore::Annotation}
////	'references' references += [eventbcore::EventBObject|EString]
//	'references' references += [ecore::EObject]
//
//
////	'source'  source = 'ac.soton.diagrams.translationTarget'
// //    'source'  source = Xsource
//;	



//Xsource returns ecore::EString:
//	  STRING
//;

AbstractNode returns AbstractNode:
	State | Initial | Final | Any | Junction | Fork;

EString returns ecore::EString:
	STRING | ID;

QualifiedName:
	ID('.'ID)?
;

Transition returns Transition:
	'transition'
//		('elaborates' elaborates+=[emachine::Event|QualifiedName]+)?
		('elaborates' elaborates+=[emachine::Event|EString]+)?
		(extended?='extended')?
//		('refines' refines=[coreextension::EventBEventGroup|EString])?
        'source' source=[AbstractNode|QualifiedName]
		'target' target=[AbstractNode|QualifiedName]
		('any' parameters+=TypedParameter ( ',' parameters+=TypedParameter)* )?
		('where' guards+=Guard+)?
		('then' actions+=Action+)?
		('with' witnesses+=Witness+)?
		'end'
;

enum TranslationKind returns TranslationKind:
		MULTIVAR = 'variables' | SINGLEVAR = 'enumeration' | REFINEDVAR = 'REFINEDVAR';

TypedParameter returns coreextension::TypedParameter:
	name=ID ':' type=XType
;

XType returns ecore::EString:
	XComplexType ('×' XType)*
;

XComplexType:
	'ℙ' '(' XType ')' | EVENT_B_BUILDIN_TYPE | ID
;

EVENT_B_BUILDIN_TYPE returns ecore::EString:
	'BOOL' | 
	'ℤ'
;

Guard returns emachine::Guard:
	(theorem?='theorem')? name=XLABEL predicate= XFormula
;

Action returns emachine::Action:
	name=XLABEL action=XFormula
;

Witness returns emachine::Witness:
	name=XLABEL	predicate=XFormula
;


State returns State:
	'State'
	name=EString
	('refines' refines=[State|QualifiedName])?
	('statemachines' 'begin' statemachines+=Statemachine ( statemachines+=Statemachine)* 'end' )?
	('invariants' invariants+=Invariant+ )?
	('entryActions' entryActions+=Action+ )?
	('exitActions' exitActions+=Action+ )?
;

Invariant returns emachine::Invariant:
	theorem?='theorem' name=XLABEL predicate=XFormula
;

Initial returns Initial:
	'Initial' name=EString
;

Final returns Final:
	'Final'	name=EString
;

Any returns Any:
	'Any' name=EString
;

Junction returns Junction:
	'Junction' name=EString
;

Fork returns Fork:
	'Fork' name=EString
;


terminal XLABEL returns ecore::EString:
	'@' !(':')+ ':'
;

XFormula returns ecore::EString:
	(
		EVENTB_IDENTIFIER_KEYWORD |
		EVENTB_PREDICATE_SYMBOLS |
		EVENTB_EXPRESSION_SYMBOLS |
		ID |
		INT
	)+ 
;

EVENTB_IDENTIFIER_KEYWORD returns ecore::EString:
	'BOOL' |
	'FALSE' |
	'TRUE' |
	'bool' |
	'card' |
	'dom' |
	'finite' |
	'id' |
	'inter' |
	'max' |
	'min' |
	'mod' |
	'pred' |
	'prj1' |
	'prj2' |
	'ran' |
	'succ' |
	'union' |
	'ℕ1' |
	'ℕ' |
	'ℙ1' |
	'ℙ' |
	'ℤ'
;

EVENTB_PREDICATE_SYMBOLS returns ecore::EString:
	'(' | // Predicate calculus symbols
	')' |
	'⇔' | 
	'⇒' |
	'∧' | '&' |
	'∨' |
	'¬' |
	'⊤' |
	'⊥' |
	'∀' | '!' |
	'∃' | '#' |
	',' |
	'·' | '.' |
	'=' | // Build predicates from expressions
	'≠' |
	'≤' |
	'<' |
	'≥' |
	'>' |
	'∈' | ':' | // Include this for Rodin keyboard
	'∉' | 
	'⊂' |
	'⊄' |
	'⊆' |
	'⊈' |
	'partition' // This is missing from the Rodin D7 deliverable
;

EVENTB_EXPRESSION_SYMBOLS returns ecore::EString:
	'↔' | // Symbols for building set of relations
	'' |
	'' |
	'' |
	'⇸' |
	'→' |
	'⤔' |
	'↣' |
	'⤀' |
	'↠' |
	'⤖' |
	'{' | // Symbols for manipulating sets
	'}' |
	'↦' |
	'∅' |
	'∩' |
	'∪' |
	'∖' |
	'×' |
	'[' | // Symbols for manipulating functions and relations
	']' |
	'' |
	'∘' |
	';' |
	'⊗' |
	'∥' |
	'∼' |
	'◁' |
	'⩤' |
	'▷' |
	'⩥' |
	'λ' | '%' // Symbols for quantified expressions
	'⋂' |
	'⋃' |
	'∣' |
	'‥' | // Symbols for arithmetic expressions
	'+' |
	'−' | '-' |
	'∗' | '*' |
	'÷' | '/' | 
	'^' |
	'\\' // Allowed for LaTeX combos
;

@Override 
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_'| 'i'..'\u00D6' | '\u00D8'..'ￜ') ('a'..'z'|'A'..'Z'|'_'| 'i'..'\u00D6' | '\u00D8'..'ￜ'|'0'..'9' | "'")*;
